# Конструктор ложементов — правила для агента (Codex)

## Цель проекта
Веб-конструктор раскладки инструментов в габаритах ложемента (EVA-foam) + детерминированная генерация G-code для ЧПУ.

## Что является продуктом сервиса
- `.nc` — внутренний технологический артефакт производства.
- `.nc` не является продуктом сервиса и не является файлом, который отдаётся клиенту как конечная ценность.
- Конечный продукт сервиса — физически изготовленный ложемент.

## Статусы заказа
Канонический жизненный цикл заказа:
- `created` — заказ создан;
- `confirmed` — заказ подтверждён после оплаты;
- `produced` — заказ изготовлен.

Сразу после создания заказа должна быть точка интеграции: переход на оплату + передача данных в 1С/документооборот (без реализации в текущем этапе).

## Жёсткие инварианты (не ломать)
- Frontend «тупой», Backend «умный»: все производственные преобразования и G-code — только на backend.
- Единицы: `1 px == 1 mm` всегда. Никаких скрытых пересчётов и «удобных» масштабов.
- Стабильные идентификаторы важнее удобства: `id` FS-safe, создаётся один раз и используется в файлах/JSON/G-code.
- Domain — единственный источник истины по каталогу: `domain/contours/manifest.json` + папки `svg/`, `nc/`, `preview/`.
- В `manifest.assets.*` хранятся ОТНОСИТЕЛЬНЫЕ пути БЕЗ ведущего `/`:
  - `svg/<id>.svg`, `nc/<id>.nc`, `preview/<id>.<ext>`
- Координаты для контура на фронте: использовать `obj.aCoords.tl` (top-left bbox) — это осознанная семантика.
- Все проверки/экспорт на фронте выполняются при `scale=1` (паттерн `performWithScaleOne()`).
- Manifest нельзя получать как статик (`/contours/manifest.json` закрыт nginx). Использовать только `GET /api/contours/manifest`.

на проде есть systemd unit layment-backend.service и nginx site layment-designer
(детали ExecStart/alias — в `DEPLOYMENT.md`)

## URL-неймспейсы (канон)
- Public API: `/api/*`
- Admin API: `/admin/api/*`
- Admin UI: `/admin` (static)
- Domain static: `/contours/*` (раздача `domain/contours`)

## Orders — идентификаторы и имена файлов (канон)
- `orderId` — имя папки заказа: `orders/<orderId>/...`
- `orderNumber` — номер заказа вида `K-00001` и префикс производственных файлов:
  - `<orderNumber>.nc`, `<orderNumber>.png`, `<orderNumber>.svg`, `<orderNumber>.dxf`, `<orderNumber>_labels.dxf`

## Контракт export (frontend -> backend) — стабилен (но расширен)

Request JSON:

```json
{
  "orderMeta": { "width": "mm", "height": "mm", "units": "mm", "coordinateSystem": "origin-top-left" },
  "contours": [
    { "id": "str", "x": "mm", "y": "mm", "angle": "deg", "scaleOverride": "number" }
  ],
  "primitives": [],
  "labels": []
}
```
Backend обязан читать orderMeta.width/height, а не ширину/высоту на верхнем уровне.

Дополнительно (опционально, для “снимка” раскладки в заказе):
- layoutPng (base64 payload / data-url),
- layoutSvg (строка SVG).

Response JSON:
всегда возвращает orderId и orderNumber (+ pricePreview / status).


## Добавление артикула (админ-пайплайн):

Добавление артикула — два явных шага:
- metadata → получение канонического id от backend
- upload файлов (SVG/NC/preview) только для существующего id

Преобразования геометрии должны происходить до runtime (admin-этап), а не “по необходимости” при заказе.

## G-code — детерминизм и сборка :

Итоговый G-code (<orderNumber>.nc) собирается детерминированно из:

- стартового шаблона (domain/gcode/start_gcode.nc)
- фрагментов каждого артикула (domain/contours/nc/*)
- фрагментов примитивов (генерация на backend)
- конечного шаблона (domain/gcode/end_gcode.nc)
- Rotation и offset применяются на backend.

## DXF — второй производственный выход (маркировка/лазер):

- Заказ должен иметь DXF артефакт(ы).
- labels — часть заказа и используется для генерации DXF под лазерную маркировку.

## Frontend vendor libs (важно) :

- Fabric.js подключаем не с CDN, а из frontend/vendor/* (пропатченная версия).
- Обновление vendor-версии делается через ./scripts/update_fabric_vendor.sh <version>

## Ограничения по технологиям
- Не добавлять новые фреймворки (frontend остаётся plain JS + fabric.js; backend остаётся FastAPI).
- Не делать «красивый» рефакторинг ради рефакторинга. Только прозрачные инженерные изменения.
- Любая смена контракта/путей — синхронно на обеих сторонах + обновить docs.

## Стиль работы агента
- Делай изменения небольшими и атомарными.
- Перед правками — найди все места использования (`ripgrep`).
- После — покажи diff и список команд для проверки.
- Не меняй публичные контракты/форматы “по-тихому”: любое изменение контракта должно быть описано в PR/коммите.